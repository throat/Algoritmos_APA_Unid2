


**
** PROGRAMAÇÃO DINAMICA
**
---------------------------------------------------------------------------------------
TRIANGULO DE PASCAL

A classe PascalTriangle implementa um algoritmo capaz de calcular o resultado
de um coeficiente binomial. Um coeficiente binomial éa  relação entre dois números 
naturais n e p, com n>=p, cujo resultado é n!/(p! (n-p)!).

O triangulo de pascal consiste em armazenar resultados de coeficientes
binomiais em uma matriz, de modo que coeficientes com mesmo numerador (n)
sejam armazenados na mesma linha, e denominador (p) na mesma coluna.

Observamos que o coeficiente binomial onde n e p são iguais é dado por
n!/p!0!, cujo resultado é sempre 1. (n! e p! se cancelam, e 0! é 1).
Finalmente, o coeficiente binomial de n e p, com n e p distintos é 
dado pelo valor do resultado do coeficiente binomial de n-1 e p-1 somados ao
coeficiente de n-1 e p. 

Complexidade: O(n*p), sendo n e p o numerador e denomidador respectivamente.

Metodos:
* int binomialCoeff(int n, k) 
- Parâmetros: n e k, inteiros referentes ao n e p do coeficiente binomial.
- Retorno: valor inteiro resultado do coeficiente binomial.

---------------------------------------------------------------------------------------
TROCO EM MOEDAS

O objetivo desta classe é calcular de quantas formas distintas pode-se
dar um troco N dado que dispoe-se de um número infinito de moedas em um 
conjunto S = {moeda1, moeda2, ... , moedaM}.

Exemplo de funcionamento: dado que queremos dar o troco de 5 centavos e
dispomos de moedas de 1, 2 e 3, o algoritmo partirá do caso base onde
nao temos troco = 0 e temos apenas moedas de 1 e irá calcular quantas
formas de dar troco podemos. (No caso, 1 forma para todos os tipos de moeda
ja que podemos nao dar nada em todos os casos).

Em seguida, incrementa-se o troco e refaz os passos para cada uma das moedas.
Neste exemplo, ao chegar no passo onde o troco é 2 e a moeda é 2, o algoritmo
aproveita que para troco 2 e moeda 1 já temos uma possibilidade e incrementa
o valor quando a moeda é 2.

 Exemplo de tabela obtida:
  i / j			1		2		3    
    0           1       1       1
    1           1		1		1
    2           1       2       2  
    3           1		2		3
    4           1		3		4
    5           1		3		5
			
			
    Valores das moedas			
    INDICES	0	1	2
    S		1	2	4

Complexidade: O(m*n), sendo m o valor do troco e n o número de moedas disponíveis.

Metodos:
*int coinChange(int S[], int n)
- Parâmetros: S[], sendo o array com  valor das moedas disponíveis e n o troco
- Retorno: numero de quantas formas pode-se dar o troco com as moedas disponíveis
           em S[].


---------------------------------------------------------------------------------------

EMPILHAMENTO DE CAIXAS

Esta classe é responsável por calcular a altura maxima que um conjunto de caixas
podem ser empilhadas, de modo que a caixa mais em baixo tenha largura e comprimento
maiores do que a caixa de cima.

Uma caixa pode ser rotacionada para ser colocada em cima de outra, ou seja, 
consideramos a caixa C1(altura, comprimento, largura) como 
c2(comprimento, altura, largura).
O algoritmo consiste em dado um array com as todas as rotações das caixas, 
para uma posicao i, calculamos a altura maxima dado que a caixa i está no topo.

Dado que o vetor de rotações é ordenado por área da base, podemos verificar 
um a um se a caixa[i+1] pode ser colocada sobre [i] e adicionamos o valor de 
sua altura a altura maxima. No fim, retornamos o resultado com a maior altura.

O detalhe da programação dinamica está quando calculamos a altura maxima com i
no topo, se for possivel colocar j acima de i, aproveitamos o resultado previamente
calculado.

Complexidade: O(n²), sendo n o número de caixas.

Estrutura de Dados:
Classe Caixa(int a, int b, int c)
*altura int
*comprimento int
*largura int

Metodos:
*int maxStackHeight( Caixa a[], int n)
- Parâmetros: a[], sendo o array de caixas disponiveis e o tamanho do array
- Retorno: altura maxima empilhando as caixas disponíveis.

---------------------------------------------------------------------------------------
CAMINHO MAIS CURTO

A classe FloydWarshall possui o método execute que recebe como entrada um 
grafo não direcionado, pois será representado por uma matriz de adjacência, 
i. é, uma matriz cujas linhas e colunas representam vértices e a posição na 
mesma representa a distância entre os mesmos. Cada iteração em K do algoritmo 
garante a melhor distância entre um vértice e outro passando por K outros vértices. 
No final de sua execução, temos uma matriz com os caminhos otimizados, na qual 
podemos verificar a menor distância de um vértice a todos os demais.

Sua complexidade é O(|V|³), em que V é o número de vértices do grafo.

Métodos:

execute (int[][] graph)
parâmetro: graph matriz de adjacêncial
Retorno: matriz com distância mais curta de cada vértice até cada outro vértice

Exemplo de entrada e saída:

         * entrada 
         * | 0   2   4   8 | 
         * | 2   0  MAX  2 | 
         * | 4  MAX  0   5 | 
         * | 8   2   5   0 |
         *
         * saída esperada
         * | 0    2    4    4 |
         * | 2    0    6    2 |
         * | 4    6    0    5 |
         * | 4    2    5    0 |
--------------------------------------------------------------------------------------

QUEBRA DE PALAVRAS

A classe WordBreaker possui o método execute recebe uma string, um HashSet dicionário de 
palavras e verifica se essa string pode ser encontrada como uma sequência de palavras 
segmentadas no dicionário. Se a palavra existir, o método retorna true, c.c., false

Sua complexidade é O(2^(n-2)) em que n é o número de palavras no dicionário

Métodos:

boolean execute (String str, HashMap dictionary)
Parâmetros: str palavra a ser buscada, dictionary o conjunto de palavras dentre as quais
str será buscada.
Retorno: verdadeiro se a palavra existe no dicionário, falso caso contrário.

Exemplo de entrada e saída:

 	* input => { Dicionário : {"João", "foi", "comprar", "pão"} Palavra :
 	* "foicomprar" }
 	*
 	* output => true


	
--------------------------------------------------------------------------------------
	
MENOR SUBSEQUENCIA COMUM

Dada duas sequências, encontrar a maior subsequencia presente em ambas as entradas,
uma subsequencia é uma sequencia presente na mesma ordem relativa, mas não necessariamente
de forma contigua ou seja, "abc", "abg", "bdf", "aeg", "acefg" são sequencias contíguas da
palavra "abcdefg", então a sua complexidade é de 2^n para uma palavra de tamanho n.
	
Ex.: SHAZAM e ALAKAZAM, Maior subsequencia comum = AZAM
	
No código:
	
Assinatura: public static String lcs(String a, String b)
	
Pelo método ser estático, não é necessário criar o objeto MSC, apenas chama-lo pela sua classe
então chama-se o metodo lcs, que tem duas Strings como entrada e retorna uma String de saida 
com a maior subsequencia comum entre as entradas

	String resultado = MSC.lcs(String a, String b);
	
	Essa função é case sensitive, logo difere maiusculas de minúsclas.
	
	Caso a String saída esteja vazia, então não existe um subsequência entre palavras
--------------------------------------------------------------------------------------
	
SOMA DE SUBCONJUNTO

Dado valores não negativos, essa função retorna se há elementos cuja soma de dois elementos
dá igual ao parametro sum
	
	Ex.: Array de entrada {4,8,33,22,10,1,15}
		 Soma esperada: 55
		 Resultado: TRUE (55 = 33 + 22)
	
	Ex.: Array de entrada {4,8,33,22,10,1,15}
		 Soma esperada: 13
		 Resultado: FALSE (Não existe soma de dois elementos que tenha esse resultado)
		 
No código:
	
	Assinatura: static boolean isSubsetSum(int set[], int sum)
	
	Pelo método ser estático, não é necessário criar o objeto SubsetSum, apenas chama-lo pela sua classe
	
	Chama-se o método isSubsetSum que tem como entrada um array de ints (int[] set) 
	e o valor soma desejado (int sum).
	
	boolean resultado = SubsetSum.isSubsetSum(array,soma);
	
	O resultado é um boolean, onde TRUE indica que há resutlado da soma e FALSE indica que não há resultados
--------------------------------------------------------------------------------------
	
DISTANCIA DE EDIÇÃO

Dada duas Strings, esse algoritmo mostra quantas operações são necessárias para se tornar a primeira
String na segunda, essas operações são:
	
	Inserção, Modificação e deleção.
	
	Util em corretores ortográficos.
	
	Ex.: String pao e paes
		 Resultado: 2 (Trocar a letra 'o' por 'e' e adicionar a letra s)
	
No código:
	
	Assinatura: static int editDistDP(String str1, String str2)
	
	Pelo método ser estático, não é necessário criar o objeto EditDistance , apenas chama-lo pela sua classe
	
	O método tem como entrada duas Strings(str1, str2), onde a primeira que sofrerá as modificações para se tornar a segunda
	
	int resultado = EditDistance.editDistDP(str1,str2)
	
	O retorno é um inteiro que dirá o menor número de operações para transformar a String 1 na String 2
	
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
	
**
**GULOSOS
**

ARVORE GERADORA MINIMA (PRIM)

O algoritmo da arvore geradora minima de prim recebe um grafo como parametro
e retorna um array que representa a arvore geradora minima deste grafo.
Consiste em criar um array booleano para cada vertice, e dado que um vertice
é visitado, elimina-o do array (boolean) e pega o próximo cuja aresta é a de
menor peso.

 Grafo exemplo

	0 ---- 1
	|      | 
	|      |
	2------3

 PESOS: 0 - 1 = 5
        0 - 2 = 7
        2 - 3 = 1
        1 - 3 = 4
O algoritmo inicia no 0 e adiciona como visitado.Em seguida, escolhe o vertice
de menor indice e que ainda nao foi visitado. Nesse caso, 1. No array de pais 
(parent[]), o indice parent[1] vai receber o valor do 0 (cuja aresta tem o menor valor)
e o nó 0 é mercado como visitado. Em seguida, pega-se procura-se pelo proximo indice
disponivel no array, que é o 1 e procura pela ligação de menor peso, que é 1 -3. 
1 é posicionado no array  parent[3] e 1 é visitado. O proximo indice é 2, e a 
ligação de menor peso é com o 3. Logo, parent[3] é colocado 2 e o laço é encerrado.
Como a raiz recebe menos -1 (pois ela nao possui um pai), o array retornado é dado 
por: [-1, 0, 1, 2]

Complexidade: O(n²), sendo N o número de vértices do grafo.

Metodos:
*int[] primMST(int graph[][])
- Parametros: grafo 2D.
- Retorno: array de inteiros com a representação de uma árvore geradora minima.

---------------------------------------------------------------------------------------


COMPRESSÃO DE DADOS (HUFFMAN)

A compressão de dados de Huffman utiliza codigo binário utilizando menos bits
para caracteres mais utilizados, economizando espaço.

Funciona da seguinte maneira: inicialmente passa-se como parametro um array
com as frequencias dos caracteres. O algoritmo adiciona essas frequencias como
folhas (HuffmanLeaf). Em seguida, são pegas duas folhas, com as menores frequencias
e cria-se um nó (HuffmanNode). A frequencia do nó é a soma das frequencias e as
antigas folhas viram filhos deste nó. O algoritmo itera até não existir mais 
referencia pra folhas. No fim, retornará uma árvore.
 
Para imprimir os códigos, uma função percorre a arvore, e para cada nó
percorrido a esquerda adiciona 0, e a direita 1. Os nós de maior frequencia,
por serem  inseridos por ultimo, ficaram proximos a raiz da árvore e 
consequentemente os códigos (caminho percorrido até a folha) será menor.

Complexidade: O(nlogn) sendo n o número de caracteres distintos.

Estrutura de Dados:
Classe HuffmanTree(int frequencia)
*frequencia int

Metodos:
*HuffmanTree buildTree(int[] charFreqs)
- Parametros: array de frequencias de caracteres
- Retorno: uma arvore com a estrutura dos codigos de huffman

*void printCodes(HuffmanTree tree, StringBuffer prefix)
- Parametros: a árvore gerada pelo método buildTree e uma variavel StringBuffer
- Retorno: Nenhum. O resultado é impresso na tela.
- OBS: para imprimir os códigos, percorre a árvore e a cada nó a esquerda adiciona 0
       e a direita 1.

---------------------------------------------------------------------------------------


CAMINHO MAIS CURTO

O algoritmo de Dijkstra recebe como parâmetro uma matriz representando um
grafo e um inteiro que representa o vértice inicial. A cada iteração do
algoritmo,é buscada a menor distância relativa ao vértice inicial dentre os e
a armazena até que todos os possíveis vértices estejam armazenados.

Sua complexidade é O(V^3) em que V é o número de vértices do grafo.

Métodos: 

int[] execute (int[][] graph, int ini)
Parâmetros: graph grafo a ser utlizado, ini vértice origem
retorno: matriz com distâncias de cada vértice até ini


Exemplo de entrada e saída:
	 
	   0 ---- 1 
	   | \    | 
	   |    \ |  (representação visual)
	   2 ---- 3
	 
Custo:
	 
	  0 - 1 = 2
	  0 - 2 = 4
	  0 - 3 = 8 (representação de pesos por aresta)
	  2 - 3 = 5
	  1 - 3 = 2
	 
Matriz de adjacência:
	 
	  | 0   2   4   8 | 
	  | 2   0  MAX  2 | 
	  | 4  MAX  0   5 | (representação em forma de matriz de adjacência)
	  | 8   2   5   0 | 

Resultado

          [0 - 0 = 0] 
          [0 - 1 = 2] 
          [0 - 2 = 4] 
          [0 - 3 = 4]

--------------------------------------------------------------------------------

ÁRVORE GERADORA MÍNIMA (KRUSKAL)

A classe Kruskal possui o método execute que implementa o método MST de Kruskal.
Kruskal calcula a menor árvore geradora para um determinado grafo. Para isso,
é necessário utilizar uma estrutura de dados que garanta ordem baseada num
determinado critério. No caso, utilizamos Maps com comparações baseadas no
peso das arestas. O algoritmo ordena todos os vértices em ordem decrescente,
checa se o menor deles forma um cíclo e, se o fizer, descarta o mesmo, então
repete o processo até que todos os vértices tenham sido visitados.

Sua complexidade é O(V log V²) em que V é o número de vértices

Métodos: Edge [] execute (Edge[] edges, int[] vertices)
Parâmetros: edges array do tipo Edge* que contém as arestas, e vertices array de inteiros
que enumera os vértices.
Retorno: array do tipo Edge com as arestas da menor árvore geradora. 

*Edge: classe que implementa a interface comparable, necessária para a utlização e manutenção
da ordenação da HashMap.
Campos:
int from
int to
int weight

Exemplo de entrada e saída:

         * 0 - 1 = 2 
         * 0 - 2 = 4 
         * 0 - 3 = 8 
         * 2 - 3 = 5 
         * 1 - 3 = 2 
         
Resultado:

         * 0 - 1 
         * 1 - 3 
         * 2 - 3
-----------------------------------------------------------------------------------------------------

MOCHILA FRACIONÁRIA
	
O algoritmo tem a seguinte estrutura: Dado uma serie de itens, o peso individual, valor individual e peso da 
mochila, qual é o maior valor obtido sem passar do peso suportado pela mochila. Nesse algoritmo objetos podem ser
partidos em pedaços menores.
	
O algoritmo ira retornar um valor double (devido as quebras dos objetos) que indicará o maior lucro possivel na mochila.
	
Então o resultado do algoritmo pode ser:
	
	Ex.: Itens completos A, itens completos B, e 5/6 do objeto C;
	
Em código:
	
	Cria-se um objeto do tipo MochilaFrac
	
	MochilaFrac MF = new MochilaFrac();
	
	Determina-se 2 arrays: Um com os pesos dos itens e outro com os valores, ou seja, no indice i de cada array indicará
	o peso e o valor do objeto i ( )
	
	Tambem tem que se indicar o peso da mochila.
	
	Assinatura: double fill(int nItens, double weight[], double benefit[], double W);
	
	Esse é o método que irá realizar o calculo do lucro máximo, ele recebe como parametro os arrays de pesos (weight[]) e valores(benefit[]) alem do
	numero de itens(nItens) e o peso da mochila (W)
	
	chamamos a função da seguinte forma:
	
	double resultado = MF.fill(numero_itens, peso[], valor[], peso_mochila)

-----------------------------------------------------------------------------------------------------
COLORAÇÃO DE GRAFOS

O algoritmo de coloração de grafos tem como objetivo colorir com o menor numero de cores possíveis, o grafo desejado, mas nós adjacentes
não podem ser coloridos da mesma cor. Esse algoritmo retorna um array de inteiros com a cor que devem ser pintados, como são itens o usuario
entenderá que o resultado será por exemplo, a cor zero no nó 0 , cor 2 no nó 1 etc.
	
Em código:
	
	Assinaturas:  CorGrafo(int v) <-- Construtor Padrão / void addNo(int v,int w) / int[] greedyColoring() 
	
	O usuário deverá criar um objeto do tipo CorGrafo, e dizendo no parenteses a quantidade de nós que existem no grafo
	
	CorGrafo CG = new CorGrafo(5) --> Grafo com cinco nós
	
	logo após o usuário deve alocar os nós usando o método addNo, que dirá qual é o nó e seu vizinho
	
	CG.addNo(0,1)
	
	Só se pode adicionar um vizinho por vez, então caso um nó tenha varios vizinhos, deve-se adicionar o mesmo nó com vizinho diferente
	
	CG.addNo(0,1)
	CG.addNo(0,2)
	
	após definir os nós basta chamar o método greedyColoring que irá retornar o array de inteiros com as cores desejadas
	
	CG.greedyColoring();
	