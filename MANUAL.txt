


**
** PROGRAMAÇÃO DINAMICA
**
---------------------------------------------------------------------------------------
TRIANGULO DE PASCAL

A classe PascalTriangle implementa um algoritmo capaz de calcular o resultado
de um coeficiente binomial. Um coeficiente binomial éa  relação entre dois números 
naturais n e p, com n>=p, cujo resultado é n!/(p! (n-p)!).

O triangulo de pascal consiste em armazenar resultados de coeficientes
binomiais em uma matriz, de modo que coeficientes com mesmo numerador (n)
sejam armazenados na mesma linha, e denominador (p) na mesma coluna.

Observamos que o coeficiente binomial onde n e p são iguais é dado por
n!/p!0!, cujo resultado é sempre 1. (n! e p! se cancelam, e 0! é 1).
Finalmente, o coeficiente binomial de n e p, com n e p distintos é 
dado pelo valor do resultado do coeficiente binomial de n-1 e p-1 somados ao
coeficiente de n-1 e p. 

Complexidade: O(n*p), sendo n e p o numerador e denomidador respectivamente.

Metodos:
* int binomialCoeff(int n, k) 
- Parâmetros: n e k, inteiros referentes ao n e p do coeficiente binomial.
- Retorno: valor inteiro resultado do coeficiente binomial.

---------------------------------------------------------------------------------------
TROCO EM MOEDAS

O objetivo desta classe é calcular de quantas formas distintas pode-se
dar um troco N dado que dispoe-se de um número infinito de moedas em um 
conjunto S = {moeda1, moeda2, ... , moedaM}.

Exemplo de funcionamento: dado que queremos dar o troco de 5 centavos e
dispomos de moedas de 1, 2 e 3, o algoritmo partirá do caso base onde
nao temos troco = 0 e temos apenas moedas de 1 e irá calcular quantas
formas de dar troco podemos. (No caso, 1 forma para todos os tipos de moeda
ja que podemos nao dar nada em todos os casos).

Em seguida, incrementa-se o troco e refaz os passos para cada uma das moedas.
Neste exemplo, ao chegar no passo onde o troco é 2 e a moeda é 2, o algoritmo
aproveita que para troco 2 e moeda 1 já temos uma possibilidade e incrementa
o valor quando a moeda é 2.

 Exemplo de tabela obtida:
  i / j		1	2	3    
    0           1       1       1
    1           1	1	1
    2           1       2       2  
    3           1	2	3
    4           1	3	4
    5           1	3	5
			
			
    Valores das moedas			
    INDICES	0	1	2
    S		1	2	4

Complexidade: O(m*n), sendo m o valor do troco e n o número de moedas disponíveis.

Metodos:
*int coinChange(int S[], int n)
- Parâmetros: S[], sendo o array com  valor das moedas disponíveis e n o troco
- Retorno: numero de quantas formas pode-se dar o troco com as moedas disponíveis
           em S[].


---------------------------------------------------------------------------------------

EMPILHAMENTO DE CAIXAS

Esta classe é responsável por calcular a altura maxima que um conjunto de caixas
podem ser empilhadas, de modo que a caixa mais em baixo tenha largura e comprimento
maiores do que a caixa de cima.

Uma caixa pode ser rotacionada para ser colocada em cima de outra, ou seja, 
consideramos a caixa C1(altura, comprimento, largura) como 
c2(comprimento, altura, largura).
O algoritmo consiste em dado um array com as todas as rotações das caixas, 
para uma posicao i, calculamos a altura maxima dado que a caixa i está no topo.

Dado que o vetor de rotações é ordenado por área da base, podemos verificar 
um a um se a caixa[i+1] pode ser colocada sobre [i] e adicionamos o valor de 
sua altura a altura maxima. No fim, retornamos o resultado com a maior altura.

O detalhe da programação dinamica está quando calculamos a altura maxima com i
no topo, se for possivel colocar j acima de i, aproveitamos o resultado previamente
calculado.

Complexidade: O(n²), sendo n o número de caixas.

Estrutura de Dados:
Classe Caixa(int a, int b, int c)
*altura int
*comprimento int
*largura int

Metodos:
*int maxStackHeight( Caixa a[], int n)
- Parâmetros: a[], sendo o array de caixas disponiveis e o tamanho do array
- Retorno: altura maxima empilhando as caixas disponíveis.

---------------------------------------------------------------------------------------
CAMINHO MAIS CURTO

A classe FloydWarshall possui o método execute que recebe como entrada um 
grafo não direcionado, pois será representado por uma matriz de adjacência, 
i. é, uma matriz cujas linhas e colunas representam vértices e a posição na 
mesma representa a distância entre os mesmos. Cada iteração em K do algoritmo 
garante a melhor distância entre um vértice e outro passando por K outros vértices. 
No final de sua execução, temos uma matriz com os caminhos otimizados, na qual 
podemos verificar a menor distância de um vértice a todos os demais.

Sua complexidade é O(|V|³), em que V é o número de vértices do grafo.

Métodos:

execute (int[][] graph)
parâmetro: graph matriz de adjacêncial
Retorno: matriz com distância mais curta de cada vértice até cada outro vértice

Exemplo de entrada e saída:

         * entrada 
         * | 0   2   4   8 | 
         * | 2   0  MAX  2 | 
         * | 4  MAX  0   5 | 
         * | 8   2   5   0 |
         *
         * saída esperada
         * | 0    2    4    4 |
         * | 2    0    6    2 |
         * | 4    6    0    5 |
         * | 4    2    5    0 |
--------------------------------------------------------------------------------------

QUEBRA DE PALAVRAS

A classe WordBreaker possui o método execute recebe uma string, um HashSet dicionário de 
palavras e verifica se essa string pode ser encontrada como uma sequência de palavras 
segmentadas no dicionário. Se a palavra existir, o método retorna true, c.c., false

Sua complexidade é O(2^(n-2)) em que n é o número de palavras no dicionário

Métodos:

boolean execute (String str, HashMap dictionary)
Parâmetros: str palavra a ser buscada, dictionary o conjunto de palavras dentre as quais
str será buscada.
Retorno: verdadeiro se a palavra existe no dicionário, falso caso contrário.

Exemplo de entrada e saída:

 	* input => { Dicionário : {"João", "foi", "comprar", "pão"} Palavra :
 	* "foicomprar" }
 	*
 	* output => true


--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
	
**
**GULOSOS
**

ARVORE GERADORA MINIMA (PRIM)

O algoritmo da arvore geradora minima de prim recebe um grafo como parametro
e retorna um array que representa a arvore geradora minima deste grafo.
Consiste em criar um array booleano para cada vertice, e dado que um vertice
é visitado, elimina-o do array (boolean) e pega o próximo cuja aresta é a de
menor peso.

 Grafo exemplo

	0 ---- 1
	|      | 
	|      |
	2------3

 PESOS: 0 - 1 = 5
        0 - 2 = 7
        2 - 3 = 1
        1 - 3 = 4
O algoritmo inicia no 0 e adiciona como visitado.Em seguida, escolhe o vertice
de menor indice e que ainda nao foi visitado. Nesse caso, 1. No array de pais 
(parent[]), o indice parent[1] vai receber o valor do 0 (cuja aresta tem o menor valor)
e o nó 0 é mercado como visitado. Em seguida, pega-se procura-se pelo proximo indice
disponivel no array, que é o 1 e procura pela ligação de menor peso, que é 1 -3. 
1 é posicionado no array  parent[3] e 1 é visitado. O proximo indice é 2, e a 
ligação de menor peso é com o 3. Logo, parent[3] é colocado 2 e o laço é encerrado.
Como a raiz recebe menos -1 (pois ela nao possui um pai), o array retornado é dado 
por: [-1, 0, 1, 2]

Complexidade: O(n²), sendo N o número de vértices do grafo.

Metodos:
*int[] primMST(int graph[][])
- Parametros: grafo 2D.
- Retorno: array de inteiros com a representação de uma árvore geradora minima.

---------------------------------------------------------------------------------------


COMPRESSÃO DE DADOS (HUFFMAN)

A compressão de dados de Huffman utiliza codigo binário utilizando menos bits
para caracteres mais utilizados, economizando espaço.

Funciona da seguinte maneira: inicialmente passa-se como parametro um array
com as frequencias dos caracteres. O algoritmo adiciona essas frequencias como
folhas (HuffmanLeaf). Em seguida, são pegas duas folhas, com as menores frequencias
e cria-se um nó (HuffmanNode). A frequencia do nó é a soma das frequencias e as
antigas folhas viram filhos deste nó. O algoritmo itera até não existir mais 
referencia pra folhas. No fim, retornará uma árvore.
 
Para imprimir os códigos, uma função percorre a arvore, e para cada nó
percorrido a esquerda adiciona 0, e a direita 1. Os nós de maior frequencia,
por serem  inseridos por ultimo, ficaram proximos a raiz da árvore e 
consequentemente os códigos (caminho percorrido até a folha) será menor.

Complexidade: O(nlogn) sendo n o número de caracteres distintos.

Estrutura de Dados:
Classe HuffmanTree(int frequencia)
*frequencia int

Metodos:
*HuffmanTree buildTree(int[] charFreqs)
- Parametros: array de frequencias de caracteres
- Retorno: uma arvore com a estrutura dos codigos de huffman

*void printCodes(HuffmanTree tree, StringBuffer prefix)
- Parametros: a árvore gerada pelo método buildTree e uma variavel StringBuffer
- Retorno: Nenhum. O resultado é impresso na tela.
- OBS: para imprimir os códigos, percorre a árvore e a cada nó a esquerda adiciona 0
       e a direita 1.

---------------------------------------------------------------------------------------


CAMINHO MAIS CURTO

O algoritmo de Dijkstra recebe como parâmetro uma matriz representando um
grafo e um inteiro que representa o vértice inicial. A cada iteração do
algoritmo,é buscada a menor distância relativa ao vértice inicial dentre os e
a armazena até que todos os possíveis vértices estejam armazenados.

Sua complexidade é 

Métodos: 

int[] execute (int[][] graph, int ini)
Parâmetros: graph grafo a ser utlizado, ini vértice origem
retorno: matriz com distâncias de cada vértice até ini


Exemplo de entrada e saída:
	 
	   0 ---- 1 
	   | \    | 
	   |    \ |  (representação visual)
	   2 ---- 3
	 
Custo:
	 
	  0 - 1 = 2
	  0 - 2 = 4
	  0 - 3 = 8 (representação de pesos por aresta)
	  2 - 3 = 5
	  1 - 3 = 2
	 
Matriz de adjacência:
	 
	  | 0   2   4   8 | 
	  | 2   0  MAX  2 | 
	  | 4  MAX  0   5 | (representação em forma de matriz de adjacência)
	  | 8   2   5   0 | 

Resultado

          [0 - 0 = 0] 
          [0 - 1 = 2] 
          [0 - 2 = 4] 
          [0 - 3 = 4]

--------------------------------------------------------------------------------

ÁRVORE GERADORA MÍNIMA (KRUSKAL)

A classe Kruskal possui o método execute que implementa o método MST de Kruskal.
Kruskal calcula a menor árvore geradora para um determinado grafo. Para isso,
é necessário utilizar uma estrutura de dados que garanta ordem baseada num
determinado critério. No caso, utilizamos Maps com comparações baseadas no
peso das arestas. O algoritmo ordena todos os vértices em ordem decrescente,
checa se o menor deles forma um cíclo e, se o fizer, descarta o mesmo, então
repete o processo até que todos os vértices tenham sido visitados.

Sua complexidade é O(V log V²) em que V é o número de vértices

Métodos: Edge [] execute (Edge[] edges, int[] vertices)
Parâmetros: edges array do tipo Edge* que contém as arestas, e vertices array de inteiros
que enumera os vértices.
Retorno: array do tipo Edge com as arestas da menor árvore geradora. 

*Edge: classe que implementa a interface comparable, necessária para a utlização e manutenção
da ordenação da HashMap.
Campos:
int from
int to
int weight

Exemplo de entrada e saída:

         * 0 - 1 = 2 
         * 0 - 2 = 4 
         * 0 - 3 = 8 
         * 2 - 3 = 5 
         * 1 - 3 = 2 
         
Resultado:

         * 0 - 1 
         * 1 - 3 
         * 2 - 3
-----------------------------------------------------------------------------------------------------

